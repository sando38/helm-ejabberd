name: CI | deploy & test
on:
  push:
    branches:
      - "*"
    paths-ignore:
      - '**.md'
  pull_request:
    branches:
      - "main"
    paths-ignore:
      - '**.md'
env:
  DB: "ejabberdTest1"
  DB_PASS: "ejabberdTest1Pass"
  KIND_VSN: "0.20.0"
  METALLB_VSN: "0.13.7"
  CHAOS_VSN: "2.6.1"

jobs:
  deploy_test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        dbApp: [pgsql, mariadb, mysql, mssql]
        dbSchema: [default, new]
        dbBaseline: [23.04, none]
      fail-fast: false
    steps:
      - name: Check out code
        uses: actions/checkout@v1

      - name: Lint helm chart
        working-directory: ./charts/ejabberd
        run: |
          helm lint .

      - name: Create KinD v${{ env.KIND_VSN }} cluster
        run: |
          curl -Lo /tmp/kind https://kind.sigs.k8s.io/dl/v${{ env.KIND_VSN }}/kind-linux-amd64
          chmod +x /tmp/kind
          /tmp/kind create cluster --config=$GITHUB_WORKSPACE/.github/ci/kind-conf.yml
          kubectl get nodes -o wide
          echo "DB_APP=$(echo ${{ matrix.dbApp }} | sed -e 's|pgsql|postgresql|')" >> $GITHUB_ENV

      # https://kind.sigs.k8s.io/docs/user/loadbalancer/
      - name: Deploy metalLB v${{ env.METALLB_VSN }} for LoadBalancer services
        run: |
          kubectl apply -f https://raw.githubusercontent.com/metallb/metallb/v${{ env.METALLB_VSN }}/config/manifests/metallb-native.yaml
          kubectl wait --namespace metallb-system \
                --for=condition=ready pod \
                --selector=app=metallb \
                --timeout=90s

          ipam="$(docker network inspect -f '{{.IPAM.Config}}' kind | awk '{gsub("[\\[\\{\\.]", " "); print  $1"."$2}')"

          kubectl apply -f - <<-EOF
          apiVersion: metallb.io/v1beta1
          kind: IPAddressPool
          metadata:
            name: kind-ipaddresspool
            namespace: metallb-system
          spec:
            addresses:
            - $ipam.255.200-$ipam.255.250
          ---
          apiVersion: metallb.io/v1beta1
          kind: L2Advertisement
          metadata:
            name: kind-l2advertisment
            namespace: metallb-system
          EOF

      - name: Setup chaos mesh v${{ env.CHAOS_VSN }}
        run: |
          curl -sSL https://mirrors.chaos-mesh.org/v${{ env.CHAOS_VSN }}/install.sh \
            | bash -s -- --local kind --kind-version v${{ env.KIND_VSN }}

      - name: Create self signed certificate
        run: |
          openssl req -x509 -newkey rsa:4096 -nodes -subj '/CN=${{ github.run_id }}-${{ strategy.job-index }}.example.com' -keyout server.pem -days 365
          kubectl create secret generic custom-cert --from-file=./server.pem
          kubectl label secret custom-cert "helm-ejabberd/watcher=true"
          kubectl annotate secret custom-cert "k8s-sidecar-target-directory=certs/custom-cert"

      - name: Deploy redis helm chart
        run: |
          helm install redis oci://registry-1.docker.io/bitnamicharts/redis \
            -f .github/ci/values-bitnami-redis.yaml

      - name: w/ db baseline ${{ matrix.dbSchema }} | deploy ${{ matrix.dbApp }} helm chart
        if: matrix.dbBaseline != 'none' && matrix.dbApp != 'mssql'
        run: |
          echo ">> install ${{ matrix.dbApp }} helm chart"
          kubectl apply -f .github/ci/flyway-baseline/${{ matrix.dbBaseline }}/${{ matrix.dbApp }}-${{ matrix.dbSchema }}.yaml

          if [ "${{ matrix.dbApp }}" = 'pgsql' ]
          then
            initdb="--set primary.initdb.user=${{ env.DB }} \
              --set primary.initdb.password=${{ env.DB_PASS }} \
              --set primary.initdb.scriptsConfigMap=ejabberd-${{ matrix.dbApp }}-${{ matrix.dbSchema }}"
          elif [ "${{ matrix.dbApp }}" = 'mariadb' ] || [ "${{ matrix.dbApp }}" = 'mysql' ]
          then
            initdb="--set initdbScriptsConfigMap=ejabberd-mysql-${{ matrix.dbSchema }}"
          fi

          helm install ${{ matrix.dbApp }} oci://registry-1.docker.io/bitnamicharts/${{ env.DB_APP }} \
            -f .github/ci/values-bitnami-${{ matrix.dbApp }}.yaml ${initdb:-}

          echo ">> check rollout status"
          kubectl rollout status sts ${{ matrix.dbApp }}

          kubectl delete -f .github/ci/flyway-baseline/${{ matrix.dbBaseline }}/${{ matrix.dbApp }}-${{ matrix.dbSchema }}.yaml

      - name: w/o db baseline | deploy ${{ matrix.dbApp }} helm chart
        if: matrix.dbBaseline == 'none' && matrix.dbApp != 'mssql'
        run: |
          helm install ${{ matrix.dbApp }} oci://registry-1.docker.io/bitnamicharts/${{ env.DB_APP }} \
            -f .github/ci/values-bitnami-${{ matrix.dbApp }}.yaml

          echo ">> check rollout status"
          kubectl rollout status sts ${{ matrix.dbApp }}

      - name: Deploy ${{ matrix.dbApp }} resources
        if: matrix.dbApp == 'mssql'
        run: |
          echo ">> install ${{ matrix.dbApp }} CI resources"

          if [ ! "${{ matrix.dbBaseline }}" = 'none' ]
          then
            kubectl apply -f .github/ci/flyway-baseline/${{ matrix.dbBaseline }}/${{ matrix.dbApp }}-${{ matrix.dbSchema }}.yaml
          else
            kubectl apply -f .github/ci/flyway-baseline/${{ matrix.dbApp }}-initdb.yaml
          fi

          kubectl apply -f .github/ci/mssql-ci.yaml

          echo ">> check rollout status"
          kubectl rollout status sts ${{ matrix.dbApp }}
          sleep 30s

          echo ">> create initDB for mssql and optionally migrate db baseline"
          kubectl exec sts/mssql -- /opt/mssql-tools/bin/sqlcmd -U SA -P "${{ env.DB_PASS }}" -S localhost -i /tmp/mssql/initdb_mssql.sql

          if [ ! "${{ matrix.dbBaseline }}" = 'none' ]
          then
            kubectl exec sts/mssql -- /opt/mssql-tools/bin/sqlcmd -U SA -P "${{ env.DB_PASS }}" -S localhost -d "${{ env.DB }}" -i /tmp/mssql/V${{ matrix.dbBaseline }}__ejabberd.sql
            kubectl delete -f .github/ci/flyway-baseline/${{ matrix.dbBaseline }}/${{ matrix.dbApp }}-${{ matrix.dbSchema }}.yaml
          fi

      - name: Check ${{ matrix.dbApp }} deployment
        run: |
          echo ">> print resources"
          kubectl get all -o wide
          echo ">> print database log entries"
          kubectl logs sts/${{ matrix.dbApp }}

      - name: Use custom run scripts
        run: |
          kubectl create cm run-ejabberd --from-file=./image/78f81de252dc932cd47b91d1a84ca8e8f0647498/scripts/run.sh

      - name: w/ sql schema ${{ matrix.dbSchema }} | deploy ejabberd helm chart
        working-directory: ./charts/ejabberd
        run: |
          echo ">> install ejabberd helm chart"
          if [ ! ${{ matrix.dbBaseline }} = 'none' ]
          then baseline="--set sqlDatabase.flyway.baselineVersion=${{ matrix.dbBaseline }}"
          fi

          if [ ${{ matrix.dbSchema }} = 'new' ]
          then sql_schema="--set sqlDatabase.newSqlSchema=true"
          fi

          if [ "${{ matrix.dbApp }}" = 'pgsql' ]
          then
            sql_options="--set sqlDatabase.config.sql_type=${{ matrix.dbApp }} \
              --set sqlDatabase.config.sql_server=${{ matrix.dbApp }} \
              --set sqlDatabase.flyway.keyValue=?sslmode=disable"
          elif [ ${{ matrix.dbApp }} = 'mysql' ] || [ ${{ matrix.dbApp }} = 'mariadb' ]
          then
            sql_options="--set sqlDatabase.config.sql_type=mysql \
              --set sqlDatabase.config.sql_server=${{ matrix.dbApp }} \
              --set sqlDatabase.flyway.keyValue=?useSSL=false \
              --set sqlDatabase.flyway.mysqlFlavor=${{ matrix.dbApp }}"
          elif [ "${{ matrix.dbApp }}" = 'mssql' ]
          then
            sql_options="--set sqlDatabase.config.sql_type=${{ matrix.dbApp }} \
              --set sqlDatabase.config.sql_server=${{ matrix.dbApp }} \
              --set sqlDatabase.flyway.keyValue=;integratedSecurity=false;encrypt=false;trustServerCertificate=true;"
          fi

          helm install ejabberd \
            -f ../../.github/ci/values-ejabberd.yaml \
            ${baseline:-} ${sql_schema:-} ${sql_options:-} \
            --set hosts[0]=${{ github.run_id }}-${{ strategy.job-index }}.example.com \
            --set logging.loglevel=debug .

          echo ">> check rollout status"
          kubectl rollout status sts ejabberd

      - name: Print resources, verify deployements
        run: kubectl get all -o wide

      - name: Print logs from ejabberd sidecar
        run: kubectl logs sts/ejabberd -c watcher

      - name: Print logs from ejabberd container
        run: kubectl logs sts/ejabberd -c ejabberd

      - name: Check ejabberd statefulset
        run: |
          kubectl exec sts/ejabberd -c ejabberd -- ejabberdctl status
          kubectl exec sts/ejabberd -c ejabberd -- ejabberdctl register admin ${{ github.run_id }}-${{ strategy.job-index }}.example.com password
          kubectl exec sts/ejabberd -c ejabberd -- ejabberdctl list_cluster

      - name: Call ejabberd API
        run: |
          LB_IP=$(kubectl get svc/ejabberd -o=jsonpath='{.status.loadBalancer.ingress[0].ip}')
          curl -L -d "{}" -X POST -k http://${LB_IP}:5280/api/status

      - name: Upgrade ejabberd helm chart
        working-directory: ./charts/ejabberd
        run: |
          helm upgrade ejabberd --no-hooks --reuse-values \
            --set logging.loglevel=info .

          echo ">> check rollout status"
          kubectl rollout status sts ejabberd

          echo ">> print ejabberd logs"
          kubectl logs sts/ejabberd -c ejabberd

      - name: Run chaos tests
        run: |
          kubectl apply -f .github/ci/chaos-mesh/chaos.yaml
          echo ">> sleep shortly"
          sleep 10s

      - name: Push some commands to ejabberd
        run: |
          echo ">> print resources"
          kubectl get all -o wide

          echo ">> check rollout status"
          kubectl rollout status sts ejabberd

          echo ">> Call ejabberd API"
          LB_IP=$(kubectl get svc/ejabberd -o=jsonpath='{.status.loadBalancer.ingress[0].ip}')
          curl -L -d "{}" -X POST -k http://${LB_IP}:5280/api/status

          L="1 2 3 4 5 6 7 8 9"
          for l in $L
          do
            kubectl exec sts/ejabberd -c ejabberd -- ejabberdctl register user$l ${{ github.run_id }}-${{ strategy.job-index }}.example.com password$l
          done

      - name: Print resources
        if: failure() || success()
        run: kubectl get all -o wide

      - name: Print ejabberd logs - ejabberd-0
        if: failure() || success()
        run: kubectl logs ejabberd-0 -c ejabberd

      - name: Print ejabberd logs - ejabberd-1
        if: failure() || success()
        run: kubectl logs ejabberd-1 -c ejabberd

      - name: Print ejabberd logs - ejabberd-2
        if: failure() || success()
        run: kubectl logs ejabberd-2 -c ejabberd
